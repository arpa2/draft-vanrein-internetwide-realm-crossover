<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>InternetWide Identities with Realm Crossover</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Bring Your Own IDentity as a Usage Pattern">
<link href="#rfc.section.3" rel="Chapter" title="3 Grammar of Identities">
<link href="#rfc.section.4" rel="Chapter" title="4 Example Use Cases">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Example of a Local Identity Grammar">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Example Targets for Access Control">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Example Regimen for Access Control">
<link href="#rfc.section.5" rel="Chapter" title="5 Realm Crossover Techniques">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Realm Crossover for Kerberos">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Realm Crossover for SASL">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Realm Crossover for PKIX">
<link href="#rfc.section.6" rel="Chapter" title="6 New Application Protocols">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Remote PKCS #11">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Keyful Identity Protocol">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Helm Access (from Arbitrary Nodes)">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 InternetWide Roaming">
<link href="#rfc.references" rel="Chapter" title="7 Normative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.38.1 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Van Rein, R." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-vanrein-internetwide-realm-crossover-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2020-09-28" />
  <meta name="dct.abstract" content="Domains and domain user identities are available in many protocols, and can be expressed as part of the URI grammar.  This document outlines how clients can bring their self-controlled identities over when crossing over to foreign realms that rely on authenticated user identities. " />
  <meta name="description" content="Domains and domain user identities are available in many protocols, and can be expressed as part of the URI grammar.  This document outlines how clients can bring their self-controlled identities over when crossing over to foreign realms that rely on authenticated user identities. " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">R. Van Rein</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">InternetWide.org</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">September 28, 2020</td>
</tr>
<tr>
<td class="left">Expires: April 1, 2021</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">InternetWide Identities with Realm Crossover<br />
  <span class="filename">draft-vanrein-internetwide-realm-crossover-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Domains and domain user identities are available in many protocols, and can be expressed as part of the URI grammar.  This document outlines how clients can bring their self-controlled identities over when crossing over to foreign realms that rely on authenticated user identities.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on April 1, 2021.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2020 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Bring Your Own IDentity as a Usage Pattern</a>
</li>
<li>3.   <a href="#rfc.section.3">Grammar of Identities</a>
</li>
<li>4.   <a href="#rfc.section.4">Example Use Cases</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Example of a Local Identity Grammar</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Example Targets for Access Control</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Example Regimen for Access Control</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">Realm Crossover Techniques</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Realm Crossover for Kerberos</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">Realm Crossover for SASL</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Realm Crossover for PKIX</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">New Application Protocols</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Remote PKCS #11</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Keyful Identity Protocol</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Helm Access (from Arbitrary Nodes)</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">InternetWide Roaming</a>
</li>
</ul><li>7.   <a href="#rfc.references">Normative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Many protocols identify clients and servers through a domain name or a user at a domain name.  Domain names follow the stepwise delegation of authority that is engrained in DNS, and an added username is generally considered a further refinement that falls under the authority of the named domain.</p>
<p id="rfc.section.1.p.2">URI grammar mirrors this idea in its authority section.  Some additional information is present to facilitate resource location beyond an identity; these involve the scheme and an optional port, and for some schemes there may be a host name as a mild overspecification for a domain.</p>
<p id="rfc.section.1.p.3">InternetWide Identity, as introduced herein, allows domain.name and user@domain.name identity forms across protocols, and when included in a URI it treats any path, query part, port, URI scheme and host-instead-of-a-domain as information beyond the abstraction level of interest to identity.  In other words, variable paths, host names, ports and service protocols can occur in URIs that represent the same identity.</p>
<p id="rfc.section.1.p.4">InternetWide Identities are domain-scoped and intended for use in foreign servers that may reside in the client's domain or any other domain.  We informally refer to this idea as "Bring Your Own IDentity (BYOID)" and to the technology facilitating it as "Realm Crossover" for domain.name and user@domain.name identities.</p>
<p id="rfc.section.1.p.5">Within a protocol, the client and service may each have their own identity and when represented as a URI they may differ in many ways, specifically including a possibly different domain name.  This is common for communication protocols such as SMTP or XMPP.  It is less common for protocols granting access to resources, like HTTP, where resources may be specified with a URI but client identity is an after-thought that gets mixed into that one URI as though it were a service-side identity.  This conflation of client and service domain relaxes when the client identity is described with its own URI, allowing better integration with the client realm and other services working for it.</p>
<p id="rfc.section.1.p.6">Foreign services generally implement some form of access control, founded on an authenticated client identity.  The process of authentication validates the client domain name through such mechanisms as DNSSEC with DANE and TLS.  An identity callback to the client realm can then add the user part of the client identity, according to a source whose prerogative it is to define it.  The foreign service composes the domain.name that it validated for the client with this user part to find a user@domain.name.</p>
<p id="rfc.section.1.p.7">Since the client's username is provided under a domain's authority over user names, it is possible to modify that part before it is supplied to the foreign service.  The name of the foreign service can be a parameter in making this choice, especially when it is authenticated.  This point of change to the user name can be helpful to change to an alias for client privacy; it may be used to slip into a group or role; and it can support clients from yet another realm to be represented by an alias or group or role under the client domain.</p>
<p id="rfc.section.1.p.8">This document only outlines the ideas and protocol modifications that can realise them.  Specifics for each of the implements are deferred to separate documents, even when the concepts described herein have already been shown to work in code.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#byoid" id="byoid">Bring Your Own IDentity as a Usage Pattern</a>
</h1>
<p id="rfc.section.2.p.1">The general usage pattern introduced with InternetWide Identity is one where a client controls a set of usernames, residing under a realm of its own choosing.  This client realm is implemented under a client domain name.  The client may approach services running under the same or any foreign domain.  In either case, the client brings their own identity composed of the client username and client domain; the client realm actively facilitates authentication under this composite identity.</p>
<p id="rfc.section.2.p.2">As part of client control over their own identity, a service-specific client username may be selected from among a set of pseudonyms available to the cient.  This enables the client to manage their identity, and the client realm can provide a number of forms to facilitate this; clients may create fresh identities or offer "+alias" extensions, or switch to any of a group member or role occupant, or even to a shared identity for an entire group or role.  The client realm or their user agent may remember choices made in the past and suggest them again during new encounters with the same service.</p>
<p id="rfc.section.2.p.3">The design challenge of InternetWide Identity is to facilitate these patterns in current-day protocols.  This calls for additional Realm Crossover protocols and techniques, and the sections below outline how application protocols with Kerberos [<a href="#kxover" class="xref">Section 5.1</a>] and/or SASL [<a href="#sxover" class="xref">Section 5.2</a>] authentication can be extended to connect client and service realms, usually without modifications to application-layer protocols.  It also explains how a distributed Public Key Infrastructure can be relied upon with similar techniques.</p>
<p id="rfc.section.2.p.4">The general pattern of Realm Crossover is founded on the two-level authority of a user@domain.name identity.  Though host, port and protocol as well as path and query string may be useful to locate a resource and for that reason incoporated into a URI, the proposed InternetWide Identity abstracts from those elements to allow shared identities across a variation of services and protocols.  Only the domain and the username are considered for identity.  The foreign service starts by authenticating the domain and makes an identity provider callback secured with mechanisms like DNSSEC, DANE and TLS.  The callback should be validated to a point where its authority over usernames under the domain is certain.  The callback can then be used, in a manner specific to the Realm Crossover technology, to authenticate the username underneath its domain.  The composition of these two elements, username and domain, with an "@" to separate the fields, forms the full identity as it is further considered by the foreign service.  This approach can be used for client identities, but may even be useful to validate service identites.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#defs.nai" id="defs.nai">Grammar of Identities</a>
</h1>
<p id="rfc.section.3.p.1">The grammar of client and service identities are related to the definition of a NAI with UTF-8 support <a href="#RFC7542" class="xref">[RFC7542]</a>.  However, the NAI defaults to realm-internal use but BYOID always needs to express the domain, so the root of the grammar tree is different:</p>
<pre>
identity =  utf8-username "@" utf8-realm
identity =/                   utf8-realm
</pre>
<p></p>
<p id="rfc.section.3.p.3">The grammars of utf8-username and utf8-realm follow the NAI specification [Section 2.2 of <a href="#RFC7542" class="xref">[RFC7542]</a>] and neither may include the "@" character.  The incorporated UTF-8 grammar <a href="#RFC3629" class="xref">[RFC3629]</a> only allows the shortest representation for each code point.</p>
<p id="rfc.section.3.p.4">The utf8-username and utf8-realm are both considered to be case-insensitive, so technologies relying on Realm Crossover techniques can infer identity equality when nothing differs but for letter case.</p>
<p id="rfc.section.3.p.5">The utf8-realm is a domain name under which users may be defined; note how this domain is not represented in the Internationalised Domain Name form (IDNA) <a href="#RFC5890" class="xref">[RFC5890]</a> that is used on the wire in DNS, but as an utf8-realm that can be mapped from or to IDNA for DNS-related purposes.  This allows rendering of domain names to users in the international form that they expect.</p>
<p id="rfc.section.3.p.6">Host names, if they occur in a URI or as part of a protocol, must be translated to a domain name in a manner that may be specific to the protocol, but a reasonable general strategy might be to allow precisely one level to be stripped off when no definitions in DNS suggest otherwise.</p>
<p id="rfc.section.3.p.7">For consistent BYOID portability, length considerations MUST NOT be constrained by support infrastructure beyond a general minimum, which follows the email limits [Section 4.5.3.1 of <a href="#RFC5321" class="xref">[RFC5321]</a>] and IDNA.  The utf8-username MUST be supported with sizes up to 64 octets and the domain in its DNS wire form MUST support sizes up to 255 octets.  Note that the DNS wire form can be more compressed than the utf8-realm [Section 4.2 of <a href="#RFC5890" class="xref">[RFC5890]</a>] because UTF-8 can use up to 4 octets for a Unicode code point, while IDNA can get up to a full Unicode code point per DNS octet once it is initialised; a safe minimum size to be certain to hold any utf8-realm is 1020 octets.  The size of an identity MUST therefore be supported with sizes up to 1085 octets.  Note that this imposes constraints on usable RADIUS implementations and the RADIUS User-Name attribute cannot be used to contain the utf8-realm value; the User-Name in a RADIUS implementation may even be unsuitable to carry the utf8-username, which for BYOID portability MUST be supported up to 64 octet sizes, whereas RADIUS permits a maximum size of 63 octets in the User-Name field.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#example" id="example">Example Use Cases</a>
</h1>
<p id="rfc.section.4.p.1">This section informally describes use cases that may be useful.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#nai.localid" id="nai.localid">Example of a Local Identity Grammar</a>
</h1>
<p id="rfc.section.4.1.p.1">Under the prerogative of a realm's identity provider a more specific grammar may be used, and some forms may even be distinguished by notation.  Such distinctions however, MUST NOT be assumed by foreign services and SHOULD NOT be assumed by anything in the provider's realm if that would break BYOID portability.  Having said that, we do give a few informative ideas: </p>

<ul>
<li>john@example.com might be a user</li>
<li>john+cook@example.com might be a light-weight alias, administratively scoped under user john@example.com</li>
<li>mary@example.com might be a different user, or an external user granted a local alter ego, or an unrecognisable pseudonym for john@example.com</li>
<li>cooks@example.com might be a group of users that can be addressed all at once by a variety of services, each with their own group semantics</li>
<li>cooks+john@example.com might be a group member for cooks@example.com, as an in-group pseudonym for a user under the same or another domain</li>
<li>+stove@example.com might represent a service</li>
<li>+stove+nr3+elt5@example.com might represent a service with sub-addressing parameters nr3 and elt5</li>
</ul>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#defs.resource" id="defs.resource">Example Targets for Access Control</a>
</h1>
<p id="rfc.section.4.2.p.1">The targets of access control are often called "resource".  We specify a few forms that may be useful to consider, without it meaning to be the last word.</p>
<p id="rfc.section.4.2.p.2">One form worth considering might be a Communication ACL.  For a given local identity, this ACL would list the remote (client) identities that are welcomed for communication.  A concrete usage pattern of this mechanism could be to blacklist everything but a few welcomed peers; or to whitelist everything but for invasive parties; or to graylist access and require the prospective communication partner to jump through some hoops before being welcomed.  It is RECOMMENDED to verify access from a remote identity before initiating communication with them, thus ensuring their ability to respond to the sending identity.</p>
<p id="rfc.section.4.2.p.3">The form of a Communication ACL is very general, and covers any protocol that connects a remote identity with the local identity in control of the ACL.  So, after sending an email over SMTP, a response over SIP is also possible and LDAP may grant download for public keys for the local identity based on the same Communication ACL for the local identity.  But while the Communication ACL spans across protocols, it should not span identities; a local user is likely to use pseudonyms for the specific purpose of regulating access to this identity.  Crossover should at best be limited to redirection from an access-blocking identity to a welcoming one.</p>
<p id="rfc.section.4.2.p.4">Another general form could be that of a Resource ACL, which may be centered around an identity in the form of a UUID <a href="#RFC4122" class="xref">[RFC4122]</a>.  Again, this need not be constrained to a protocol but may represent more general ideas, such as "storage space" or "versioning system".  Whether these are delivered over HTTP, LDAP, MQTT or GIT should not matter to the access control mechanism.  Related, but different, are Resource Instances, which expand a general idea with a UUID-specific string format to describe a particular instantiation of the general idea; for example, a collection or object in a storage space; for example, a repository or version in a versioning system.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#defs.acl" id="defs.acl">Example Regimen for Access Control</a>
</h1>
<p id="rfc.section.4.3.p.1">Access control is exercised while a service is accessed.  The process starts with an authenticated client identity and derives what access rights may be granted to the identified client.</p>
<p id="rfc.section.4.3.p.2">The facilitation of BYOID in access control demands that the realm in the client identity is fully taken into account.  When any local realm is at best used for compressed representation but not to differentiate rights, an access control solution can be completely open to foreign clients.</p>
<p id="rfc.section.4.3.p.3">One difference between foreign clients and local ones is the level of trust bestowed on them, another is the level of knowledge about their identity grammar.  Specifically, the username forms suggested above for "+service" or perhaps "+service+arg1+arg2+arg3", for "client+alias" or "groupname+membername" may all have local meaning, especially because for a given name part "service" or "client" or "groupname" there is some local knowledge about the kind of identity that they represent.  Though being permissive to foreign clients is vital for BYOID, differentiating rights for local identities (and identity patterns) can be useful in many operational contexts.</p>
<p id="rfc.section.4.3.p.4">As a general mechanism for access control, it is RECOMMENDED to iterate over a client identity by gradually generalising the form.  Each of the forms might be called a "selector".  Going from concrete to abstract, ach Selector could serve as a (partial) identity string while looking for matching access rules.  Such lookups could also incorporate the target of access control.  Flags representing specific access rights such as read and write could be part of the lookup or returned as a result of it.  The first identity for which an access rule matches is considered the proper one for the client identity being iterated over.</p>
<p id="rfc.section.4.3.p.5">The most specific username is the utf8-username field that passed authentication.  The most abstract username is a wildcard, which we shall write as "".  For local users, it may make sense to iterate over more specific forms as well, such as splitting after internal "+" signs.  For example, "john+cook" could yield a list "john+cook", "john+" and "" going from specific to general.</p>
<p id="rfc.section.4.3.p.6">The most specific domain name is the utf8-realm field that passed authentication.  The most abstract domain is the top-level domain ".", and intermediate domains can be written with a prefixed dot to distinguish them from a full domain name.  For example, "example.com" could yield a list "example.com", ".com" and "." going from specific to general.</p>
<p id="rfc.section.4.3.p.7">The combined iteration for a client identity uses domain iteration as an outer loop and username iteration as an inner loop.  So, combining the examples above including local interpretation of the username part, "john+cook@example.com" could yield a list "john+cook@example.com", "john+@example.com", "@example.com", "john+cook@.com", "john+@.com", "@.com", "john+cook@.", "john+@.", "@." where the latter is always the most abstract form found for a client@domain.name form.</p>
<p id="rfc.section.4.3.p.8">Most of this example list is likely to remain unused; several of these forms could be blocked with pragmatic rules, such as barring ".com" domains from an ACL.  When also the local interpretation of the username is barred, the lookups for such a remote client are reduced to "john+cook@example.com", "@example.com", "john+cook@." and "@." forms only, but for "john+cook@labs.example.com" there would still be the meaningful forms "john+cook@labs.example.com", "@labs.example.com", "john+cook@.example.com", "@.example.com", "john+cook@." and "@." to consider in the ACL.</p>
<p id="rfc.section.4.3.p.9">Note the importance of the initial dot in the domain name iteration.  It differentiates identities as defined by a realm from identities as defined by a child realm.  One other choice that an ACL might make is to constain the iteration to go up one domain level and allow "." as a wildcard domain.</p>
<p id="rfc.section.4.3.p.10">In general, the application calling for access control is in the best position to determine what to consider.  An SMTP port 25 for external submissions may not want to consider internal identity forms, whereas an SMTP port 587 for submission by internal users may desire just that.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#xover" id="xover">Realm Crossover Techniques</a>
</h1>
<p id="rfc.section.5.p.1">This section details how Realm Crossover may be established with Kerberos and SASL, and how PKIX may benefit from it.  The descriptions are provided to sketch the structure of the solution, but complete details are worked out in other documents.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#kxover" id="kxover">Realm Crossover for Kerberos</a>
</h1>
<p id="rfc.section.5.1.p.1">Kerberos uses a realm controller known as the KDC.  It is possible for the KDCs of two realms to connect, though this is not a dynamic process that can be called upon when a client first attempts to acces a foreign service.  Realm Crossover for Kerberos is an "Impromptu" extension to the existing facilities for Realm Crossover.</p>
<p id="rfc.section.5.1.p.2">Only the client KDC and service KDC need to support Realm Crossover to allow this to work.  Most current-day clients facilitate principal name canonicalization <a href="#RFC6806" class="xref">[RFC6806]</a>, which suffices for Realm Crossover.  The client KDC needs to realise that a request was made for a service that is part of an external realm, obtain a (new or pre-existing) realm-crossing relation with that realm's KDC, and respond with a server referral [Section 8 of <a href="#RFC6806" class="xref">[RFC6806]</a>] in order to redirect the client, armed with realm-crossing credentials, to the KDC of the service realm.</p>
<p id="rfc.section.5.1.p.3">For the creation of a new, impromptu realm crossover relation between two KDCs, a new protocol KXOVER has been devised.  It builds on TLS and derives a crossover key from the TLS master key.  As part of the KXOVER protocol, details such as a time window for crossover are negotiated.  Since the same crossover key can help any client on one KDC to connect to any service on another KDC, this procedure is efficient.  Only the first "impromptu" call upon the remote KDC can be somewhat time-consuming; beyond that, the procedures fall back to symmetric key management only.  When a crossover ticket is used regularly, it would make sense to refresh it before the old ticket expires.</p>
<p id="rfc.section.5.1.p.4">It is worth noting that the secrecy of the crossover keys established over TLS are only as secure as TLS is.  When no Post Quantum mechanisms are used, the crossover key derived by the client and service realm could be grounds for future abuse.  The security model of Kerberos permits derivation of all derived keys and that includes encryption keys.  Although Kerberos with proper initiation can be a Post Quantum technology, this may no longer hold under Realm Crossover.</p>
<p id="rfc.section.5.1.p.5">Kerberos supports anonymity, but that would not allow distinction between different clients.  It does not facilitate pseudonyms when requesting a particular service on another realm; the KDC however, is in a perfect position to do just that.  Extensions can be easily imagined, whereby a client sets a flag in the initial exchange to indicate support for client identity changes, either from the KDC's recollection of previous desires or from an explicit request by the client.  As long as the KDC reflects this flag, identity changes could be requested or allowed as a protocol extension.</p>
<p id="rfc.section.5.1.p.6">The current DNS records for Kerberos specify where to find the KDC for a realm, but not for a service.  This was initially considered insecure, but since then DNSSEC has been rolled out, and it can now be done securely.  This means that a client or its KDC can look for a service host or domain, infer the realm under which it resides, and lookup the ticket for the protocol and host/domain under that realm.  This is not current practice yet.</p>
<p id="rfc.section.5.1.p.7">In summary, the extensions to support Kerberos Realm Crossover are (1) the KXOVER protocol, (2) DNS lookup of realm names for hosts/domains, (3) optional support of pseudonymity.  With the exception of the optional last point, these can be implemented in the KDC alone.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#sxover" id="sxover">Realm Crossover for SASL</a>
</h1>
<p id="rfc.section.5.2.p.1">SASL authentication is built into many Internet protocols.  It facilitates an extensible set of mechanisms, passed inside the application protocol which remains blissfully unaware of its details and upgrades.</p>
<p id="rfc.section.5.2.p.2">It is not generally safe to carry SASL over plaintext connections, and the customary use case runs it within a secure application protocol, such as after a STARTTLS exchange.  To avoid undetected relaying of SASL traffic to another resource, a precaution of channel binding may be used, where non-secret but unmistaken parts of the secure application protocol are mixed into a cryptographic computation to assure that the SASL server is the assumed one.</p>
<p id="rfc.section.5.2.p.3">To support Realm Crossover, it is possible to pass SASL to a backend server over Diameter <a href="#RFC6733" class="xref">[RFC6733]</a>.  The backend would be selected for the client's realm and looked up with Diameter's NAPTR and) SRV records in DNSSEC and connected under protection of DANE and (D)TLS.  This is effectively an identity callback to a client realm.  Under Diameter, authentication is bidirectional, so the client realm is aware of the requesting service realm.</p>
<p id="rfc.section.5.2.p.4">Diameter is valuable because it is designed to authenticate across administrative domains, and pass success or failure along with descriptive attributes such as an authorisation username to a requesting service realm.  This usage is called Network Access Service <a href="#RFC7155" class="xref">[RFC7155]</a>.  The value of passing just success or failure by default is that no resources are made available; as a result, a Diameter service can be made available as a public authentication callback service, unlike a resource-supplying protocol such as IMAP.</p>
<p id="rfc.section.5.2.p.5">Care must be taken to not ever pass traffic back up from Diameter to a higher-level protocol.  SXOVER ensures this by loosing vital information in that case, namely for channel binding.  Services other than Diameter MUST reject externally supplied channel binding octet strings and instead form their own.  That way, a resource-supplying application protocol could not possible be attacked in the backend of a foreign service contacted by the client.  That is, not when channel binding is being used.  The flip-side of this coin is that the foreign service contacted by the client MUST relay channel binding information to its Diameter backend, which then forwards it to the point where cryptographic computations are performed, in the client realm.  Channel binding effectively becomes the client's authentication of the foreign service.</p>
<p id="rfc.section.5.2.p.6">Based on this, only SASL mechanisms that support channel binding are suited for Realm Crossover.  There is another requirement however, and that is end-to-end encryption.  Given that SASL mechanisms are not generally safe to pass over unencrypted channels, they cannot generally be trusted to pass through a foreign service either.  A secret between the client and its realm must be obtained beforehand, and used to encrypt the exchange.  Note the relative ease of obtaining such a key relative to proving client identity.  A special SASL mechanism can then employ this secret, along with channel binding information, to securely wrap another SASL mechanism that does not need to live up to these requirements.  That special SASL mechanism is GS2-SXOVER-PLUS; it is possible that other mechanisms are devised to allow the same usage pattern however.</p>
<p id="rfc.section.5.2.p.7">Two last concerns to note for the special SASL mechanism are that it must mention the client's realm in a form readable to the foreign server.  This part will also be validated by the foreign server, while making the Diameter back-call.  The wrapped SASL mechanism therefore does not supply the client realm, but only its username, precisely its prerogative to define.  Also, the form of channel binding used must be visible to the foreign server, so it can pack the information for relaying over Diameter.  This is generally possible with GS2 mechanisms, though other forms can have specialised representations for the same information.</p>
<p id="rfc.section.5.2.p.8">Note that not all these concerns necessarily apply for clients that are local to the "foreign" service.  Even when they may also pass over Diameter, their traffic may remain "internal" and "trusted" and therefore more mechanisms may be available than for a truly foreign client.  It is common in SASL to allow the server to present acceptable SASL mechanisms, so this can be part of operational practices.</p>
<p id="rfc.section.5.2.p.9">To allow SASL over Diameter, a few attribute-value pairs need to be defined under its Network Access Profile <a href="#RFC7155" class="xref">[RFC7155]</a>.  These are (1) SASL-Token, for relaying SASL's binary octets of a token in either direction, but only when one is supplied by the SASL endpoint; (2) SASL-Mechanism, a string listing space-separated mechanism names that are acceptable to the foreign service, or selected by the client; (3) SASL-Channel-Binding, to relay binary channel binding information from the foreign service to the client's Diameter server, and to allow the client and its realm to work out that no extra resources are in the loop.</p>
<p id="rfc.section.5.2.p.10">Not all application protocols support SASL.  Modern IRC does, and may benefit from incorporating Realm Crossover to make abusive patterns less likely, and to reserve usernames for returning clients.  The most notable omission is HTTP, which resorts to higher layers, often involving manual actions and code mixtures with executable content from uncontrolled remote sites.  An extension of HTTP with SASL is part of our proposal for realm crossover as an overall solution.</p>
<p id="rfc.section.5.2.p.11">In summary, the extensions to support SASL Realm Crossover are (1) support for SASL over Diameter, (2) the GS2-SXOVER-PLUS mechanism and its incorporation into user agents and SASL over Diameter; (3) the reliance on Diameter for client authentication in foreign servers.  Finally, (4) non-SASL-aware protocols need to be extended to support SASL.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#pkix" id="pkix">Realm Crossover for PKIX</a>
</h1>
<p id="rfc.section.5.3.p.1">The definition of PKIX references LDAP for the retrieval of certificates from a certificate's DistinguishedName.  Given the potential for access control when Realm Crossover enables requesters to authenticate, arbitrary privacy controls can be enforced using these mechanisms.  LDAP services can pass through STARTTLS and the certificate used may be assured through DNSSEC and DANE to allow remotes to validate the authority of the information in LDAP, specifically when its DistinguishedName patterns coincide with the domain name <a href="#RFC2247" class="xref">[RFC2247]</a> and when usernames are located with (uid=...) search filters.</p>
<p id="rfc.section.5.3.p.2">When identities are managed with the BYOID intent, it makes sense to create key pairs for PKIX, OpenPGP and perhaps OpenSSH and store those in LDAP for retrieval by approved parties.  This establishes the long-missed Public Key Infrastructure for the Internet, to benefit security of email and most other forms of communication.</p>
<p id="rfc.section.5.3.p.3">Note how PKIX currently relies on "central" organisations to approve of certifictes, and how LDAP may be supportive of a more distributed mechanism.  Also note how the mechanisms can be combined for maximum strength; one example use of this would be to facilitate federations with authentication that spans the Internet plus a root key that facilitates just the federation.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#newproto" id="newproto">New Application Protocols</a>
</h1>
<p id="rfc.section.6.p.1">The idea of BYOID and its technological embedding as Realm Crossover allow a few useful ideas to be worked out in new application protocols.  The general idea of these protocols is described below, but the complete details are described in other documents.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#rpkcs11" id="rpkcs11">Remote PKCS #11</a>
</h1>
<p id="rfc.section.6.1.p.1">Clients may want to use key-based mechanisms even on platforms that cannot be trusted to protect these well, such as a mobile phone or other easily lost device.  Such applications, as well as the desire to use the same keying material on multiple devices and the reflection that operational control of private keys with proper rollovers is difficult and may for a large portion of users better be left to their administrators, all combine to the idea that a Remote PKCS #11 service may be useful.</p>
<p id="rfc.section.6.1.p.2">When identities are generated along with public key certificates that can be looked up in LDAP, it is useful to facilitate the matching private keys in such a Remote PKCS #11 service.</p>
<p id="rfc.section.6.1.p.3">We have prepared an LDAP scheme to reflect private key references alongside public key certificates (with intended readability only to the key owners) and we have prepared a direct mapping of the PKCS #11 interface to a request/response format that supports locally callable functions that are actually applied remotely to private keys contained there, perhaps in a highly secured context.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#kip" id="kip">Keyful Identity Protocol</a>
</h1>
<p id="rfc.section.6.2.p.1">The enhancement of authentication with Realm Crossover allows a great diversity of new use cases; but encryption still relies on the publication of public key certificates by recipients.  When the requirement to encrypt sensitive content exists however, there is an immediate urge to have all recipient's public keys and not make an exception by sending unencrypted content to one recipient that lacks one.  In short, there is a desire for sender-initiated encryption.</p>
<p id="rfc.section.6.2.p.2">We devised a Keyful Identity Protocol (KIP) to fulfil this need.  Its essential function is to take in a symmetric key and wrap it in a manner that can only be decrypted by an authenticated party.  In other words, it provides encryption to any client who can authenticate.  The actual content is not passed over KIP, but the session keys are.</p>
<p id="rfc.section.6.2.p.3">Encryption of session keys is done with a fixed key stored in the KIP service, and cryptographically bound to an access control list.  Requests to authenticate require no authentication, and are ideally performed on a KIP service running under each recipient's domain.  To request decryption, a recipient must authenticate, and their session key can be provided when the cryptographically bound access control list allows it.</p>
<p id="rfc.section.6.2.p.4">KIP can also be used to sign a checksum, which is a notably different service from authentication.  This requires authentication by the signing party and is best done at their realm's KIP service.  To gain trust, a recipient would contact the KIP service under a (validated) signer's realm and see it approved.</p>
<p id="rfc.section.6.2.p.5">KIP Documents are a nested sequence of data and wrapped session keys and signatures.  This involves signed references, so an object may be stored outside of a KIP Document, and still be validated by it.  By defining a media type for KIP Documents, a data URI <a href="#RFC2397" class="xref">[RFC2397]</a> can be made that triggers a handler when accessed by user agents such as HTTP and SMTP clients.</p>
<p id="rfc.section.6.2.p.6">The wrapped session keys of KIP underly the GS2-SXOVER-PLUS mechanism <a href="#sxover" class="xref">Section 5.2</a>, without other dependency on the protocol; KIP service can be used to help clients to the initial key that provides end-to-end encryption between their user agent and the identity callback server in the client realm.</p>
<p id="rfc.section.6.2.p.7">In spite of its potential strength, KIP is operationally really simple to deploy.  It requires a secure storage mechanism for its fixed long-term key, but the only administrative control needed is the creation and destruction of virtual hosts; and a basic roll-out only needs one.  KIP can be a client to Realm Crossover for straightforward authentication.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#haan" id="haan">Helm Access (from Arbitrary Nodes)</a>
</h1>
<p id="rfc.section.6.3.p.1">Domains may seem to be the anchor point for online identity, but in reality they often have fallbacks to a single email address, to which unencrypted email is sent.  Other online resources reproduce this insecure habit.  Email address may go awry, and with it, possibly the control over a domain name.  The general problem here is that no problem exists for "identity bootstrapping".  Realm crossover can be used to remedy that.</p>
<p id="rfc.section.6.3.p.2">Online resources usually have a starting point, where administrative control may be exercised, including the removal of the resource and creation of new ones.  It may even include the addition of subordinate identities, such as domain users or subdomains under a domain name.  We introduce the general idea of a "Helm of Control", or helm for short, as the point of access to this facility.</p>
<p id="rfc.section.6.3.p.3">We propose the use of Realm Crossover to gain access to one's helm.  This involves authentication with a (possibly external) credential and not the ability to receive unencrypted email, so it is already more constrained.  In addition, it should be straightforward to control in a more refined access how control can be held.  At the very least, it is desirable to allow access form multiple (external) identities to have no single point of failure when it comes to access recovery.</p>
<p id="rfc.section.6.3.p.4">Use cases may involve depositing credentials with others who can serve as fallbacks for access.  This is especially useful by handing them their own access control, possibly leading to their own Helm, where they can only control those online resources that they are supposed to control.  In general, a many-to-many mapping from identity to online resource at a given provider seems the most useful.</p>
<p id="rfc.section.6.3.p.5">One use of this access pattern include control over the removal of a person's online presence, for instance by family after a loved one passes away or after a company goes into bankruptcy.  At least some laws discard an individual's right to privacy upon death and may therefore not be supportive of a family's desire to erase online presence without going through disturbing practices in full control of a service provider; and not all of them see a benefit in destroying data.</p>
<p id="rfc.section.6.3.p.6">HAAN is short for Helm Arbitrary Access Node; the HAAN service generates a worthless username and password from scratch.  Note that any fresh account is without value until it is setup with online resources, perhaps by accessing a Helm.  Though supplied by a given realm, the HAAN service for a realm does not even need to store the credentials; it generates a random username with a lot of entropy and uses an internally held, fixed key to derive an accompanying password.  Later, when a client wants to gain access, the provided username is combined with the fixed key to recompute the password and perform any desired check.</p>
<p id="rfc.section.6.3.p.7">The implementation of HAAN is founded on a SASL mechanism named GS2-HAAN-GENERATE, which should be run directly with the supporting realm (or perhaps through an end-to-end encryption tunnel like the one for SXOVER).  Later authentication is possible using any SASL mechanism that uses a password, usually with GS2-SXOVER-PLUS wrapped around it so a foreign provider can use it to gain access to its Helm.</p>
<p id="rfc.section.6.3.p.8">It is not generally advised to require authentication when adding a HAAN identity to a Helm.  First, it exchanges more credential information than strictly desired; second, users do not type identities from slips of paper but use copy/paste; third, backups exist in the form of additionally registered identities to access the helm; fourth, because HAAN can generate extra entropy to allow correction of typo's when a client enters a falsely entered identity as an authorisation identity.  When desiring a 128-bit security level, HAAN might generate 160 bits and as long as going from the proper 160-bit value to an authorisation identity can be described with entropy less than the extra 32 bits, the validation with HAAN can still provide the 128-bit security level.</p>
<p id="rfc.section.6.3.p.9">Dedicated methods can be built for HAAN-generated secrets.  One that springs to mind is TOTP <a href="#RFC6238" class="xref">[RFC6238]</a>, where the only storage needed on the server is for replay avoidance, and only when nothing specific to the SASL exchange itself avoids replay.  When replay is not to be suspected, the TOTP exchange can be accepted immediately; otherwise, a challenge/response exchange may remedy any risk of replay.  The server can safely err on the cautious side, and use something like a Bloom filter to detect possibly replay over the past timer period.</p>
<p id="rfc.section.6.3.p.10">In spite of its promising potential, HAAN is operationally really simple to deploy.  It requires a secure storage mechanism for its fixed long-term key, but the only administrative control needed is the creation and destruction of virtual hosts; and most roll-outs will only support one.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#roaming" id="roaming">InternetWide Roaming</a>
</h1>
<p id="rfc.section.6.4.p.1">Networking is increasingly becoming an application under management of users.  Network authentication is customarily generalised in EAP, whereas application authentication is generalised with SASL.  An ability to run SASL over EAP supports the use of client credentials for network access applications such as VPN, 802.1x or Bluetooth.</p>
<p id="rfc.section.6.4.p.2">When SASL is backported over Diameter, an extra option arises, where the user is offered a tunnel to a home network.  Using ESP, such a tunnel would be protected from content inspection and manipulation.  And quite interestingly, ESP could be carried over a multitude of protocols.</p>
<p id="rfc.section.6.4.p.3">When providing network access, this scheme has the benefit that nothing is known about the traffic, and so no responsibility is taken for those contents.  Furthermore, the IP address from which this content is shared is only a tunnel endpoint to a home realm, but not a general carrier for traffic.  This could be a type of service to offer without concerns.</p>
<p id="rfc.section.6.4.p.4">Packets of an ESP tunnel may travel over a variety of carriers, not just over IP.  There could be an embedding for directly carrying it over ethernet or PPP, for example.  There is an additional need for key exchange, but the UDP encapsulation for ESP <a href="#RFC3948" class="xref">[RFC3948]</a> solves that with a simple prefix to the key exchange traffic, so that a complete tunnel protocol arises.  This tunnel protocol can pass through PNAT using the UDP encapsulation.</p>
<p id="rfc.section.6.4.p.5">This allows wired and wireless ethernets to employ 802.1x access restriction with SASL over EAP, to open up an ESP/IKE uplink to a tunnel server whose address information is provided in a Diameter response when SASL over Diameter succeeds.  A base station may respond to a query for an "InternetWide Roaming" identity with just this dialog.</p>
<p id="rfc.section.6.4.p.6">Similar approaches might be employed with the Bluetooth Network Encapsulation Profile to grant nearby nodes access to an ethernet, albeit at much lower speed, but can reduce the ethernet header to just the ethernet type.  As a fallback scenario, mobile users may be helped with the older L2TP/IPsec stack which is available by default in most current-day configurations and this may serve as a fallback in circumstances where InternetWide Roaming is not available in a more direct form, but generic Internet access is.  The simplified access form however, can be particularly interesting for small devices, especially when the ESP traffic is founded on a fixed key.</p>
<p id="rfc.section.6.4.p.7">The integration of SASL into EAP adds a use case for key extraction from SASL, which is sometimes considered an older possibility, but which regains interest when it can setup end-to-end protection keys.  In a scenario where SASL is followed by ESP, it may provide extra entropy to be mixed into the key exchange <a href="#RFC8784" class="xref">[RFC8784]</a>.</p>
<h1 id="rfc.references">
<a href="#rfc.references">7.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2247">[RFC2247]</b></td>
<td class="top">
<a>Kille, S.</a>, <a>Wahl, M.</a>, <a>Grimstad, A.</a>, <a>Huber, R.</a> and <a>S. Sataluri</a>, "<a href="https://tools.ietf.org/html/rfc2247">Using Domains in LDAP/X.500 Distinguished Names</a>", RFC 2247, DOI 10.17487/RFC2247, January 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2397">[RFC2397]</b></td>
<td class="top">
<a>Masinter, L.</a>, "<a href="https://tools.ietf.org/html/rfc2397">The "data" URL scheme</a>", RFC 2397, DOI 10.17487/RFC2397, August 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3629">[RFC3629]</b></td>
<td class="top">
<a>Yergeau, F.</a>, "<a href="https://tools.ietf.org/html/rfc3629">UTF-8, a transformation format of ISO 10646</a>", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3948">[RFC3948]</b></td>
<td class="top">
<a>Huttunen, A.</a>, <a>Swander, B.</a>, <a>Volpe, V.</a>, <a>DiBurro, L.</a> and <a>M. Stenberg</a>, "<a href="https://tools.ietf.org/html/rfc3948">UDP Encapsulation of IPsec ESP Packets</a>", RFC 3948, DOI 10.17487/RFC3948, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4122">[RFC4122]</b></td>
<td class="top">
<a>Leach, P.</a>, <a>Mealling, M.</a> and <a>R. Salz</a>, "<a href="https://tools.ietf.org/html/rfc4122">A Universally Unique IDentifier (UUID) URN Namespace</a>", RFC 4122, DOI 10.17487/RFC4122, July 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5321">[RFC5321]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="https://tools.ietf.org/html/rfc5321">Simple Mail Transfer Protocol</a>", RFC 5321, DOI 10.17487/RFC5321, October 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5890">[RFC5890]</b></td>
<td class="top">
<a>Klensin, J.</a>, "<a href="https://tools.ietf.org/html/rfc5890">Internationalized Domain Names for Applications (IDNA): Definitions and Document Framework</a>", RFC 5890, DOI 10.17487/RFC5890, August 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6238">[RFC6238]</b></td>
<td class="top">
<a>M'Raihi, D.</a>, <a>Machani, S.</a>, <a>Pei, M.</a> and <a>J. Rydell</a>, "<a href="https://tools.ietf.org/html/rfc6238">TOTP: Time-Based One-Time Password Algorithm</a>", RFC 6238, DOI 10.17487/RFC6238, May 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6733">[RFC6733]</b></td>
<td class="top">
<a>Fajardo, V.</a>, <a>Arkko, J.</a>, <a>Loughney, J.</a> and <a>G. Zorn</a>, "<a href="https://tools.ietf.org/html/rfc6733">Diameter Base Protocol</a>", RFC 6733, DOI 10.17487/RFC6733, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6806">[RFC6806]</b></td>
<td class="top">
<a>Hartman, S.</a>, <a>Raeburn, K.</a> and <a>L. Zhu</a>, "<a href="https://tools.ietf.org/html/rfc6806">Kerberos Principal Name Canonicalization and Cross-Realm Referrals</a>", RFC 6806, DOI 10.17487/RFC6806, November 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7155">[RFC7155]</b></td>
<td class="top">
<a>Zorn, G.</a>, "<a href="https://tools.ietf.org/html/rfc7155">Diameter Network Access Server Application</a>", RFC 7155, DOI 10.17487/RFC7155, April 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7542">[RFC7542]</b></td>
<td class="top">
<a>DeKok, A.</a>, "<a href="https://tools.ietf.org/html/rfc7542">The Network Access Identifier</a>", RFC 7542, DOI 10.17487/RFC7542, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8784">[RFC8784]</b></td>
<td class="top">
<a>Fluhrer, S.</a>, <a>Kampanakis, P.</a>, <a>McGrew, D.</a> and <a>V. Smyslov</a>, "<a href="https://tools.ietf.org/html/rfc8784">Mixing Preshared Keys in the Internet Key Exchange Protocol Version 2 (IKEv2) for Post-quantum Security</a>", RFC 8784, DOI 10.17487/RFC8784, June 2020.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Rick van Rein</span> 
	  <span class="n hidden">
		<span class="family-name">Van Rein</span>
	  </span>
	</span>
	<span class="org vcardline">InternetWide.org</span>
	<span class="adr">
	  <span class="vcardline">Haarlebrink 5</span>

	  <span class="vcardline">
		<span class="locality">Enschede</span>,  
		<span class="region">Overijssel</span> 
		<span class="code">7544 WP</span>
	  </span>
	  <span class="country-name vcardline">The Netherlands</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:rick@openfortress.nl">rick@openfortress.nl</a></span>

  </address>
</div>

</body>
</html>
